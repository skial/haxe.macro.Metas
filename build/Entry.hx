package ;

import sys.Http;
import haxe.Json;
import haxe.Timer;
import sys.io.File;
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.macro.Printer;

using StringTools;
using haxe.io.Path;
using sys.FileSystem;

typedef TMeta = {
    name:String,
    metadata:String,
    doc:String,
    ?targets:Array<String>,
    ?platforms:Array<String>,
    ?links:Array<String>,
    ?params:Array<String>,
    ?devcomment:String,
    ?internal:Bool,
}

class Entry {

    public static final printer:Printer = new Printer();

    public static var MetasJson:String =
    if (Context.defined('metas.json')) {
        var value = Context.definedValue('meta.json').normalize();

        if (!value.isAbsolute()) {
            value = FileSystem.fullPath(Context.resolvePath(value));
        }

        value;

    } else {
        'https://raw.githubusercontent.com/HaxeFoundation/haxe/development/src-json/meta.json';

    }
    public static final cwd:String = Sys.getCwd();
    public static final MetasLocal:String = '$cwd/cached/'.normalize();

    public static var outputPath = '$cwd/src/haxe/macro/Metas.hx';

    public static function main() {
        // TODO: Should be `https`.
        var isHttps = MetasJson.startsWith('https:');

        if (isHttps && FileSystem.exists(MetasLocal + 'meta.json')) {
            MetasJson = MetasLocal + 'meta.json';
            isHttps = false;
        }

        var wait = true;
        var content = '';

        if (isHttps) {
            // TODO: Once eval supports https connections, drop tink_* libs.
            //Http.requestUrl(MetasJson);

            tink.http.Client.fetch(MetasJson, {client:Curl}).all().handle( o -> switch o {
                case Success(response):
                    wait = false;
                    content = response.body.toString();

                case Failure(e):
                    wait = false;
                    Context.fatalError('HTTPS error: $e', Context.currentPos());

            } );

        } else {
            wait = false;
            content = File.getContent(MetasJson);

        }

        var timestamp = Timer.stamp();
        while (wait) {
            if ((Timer.stamp() - timestamp) > 4) {
                Context.fatalError('Failed to load `meta.json` via https request.', Context.currentPos());
                break;
            }
        }
        
        //trace( content );

        var json:Array<TMeta> = Json.parse( content );

        if (isHttps) {
            if (!MetasLocal.exists()) MetasLocal.createDirectory();
            File.saveContent( MetasLocal + '/meta.json', content );

        }

        var pos = Context.currentPos();
        var fields = [];
        for (meta in json) {
            //trace( define );
            var name = meta.name;
            var expr = {expr:EConst(CString(meta.metadata)), pos:pos};
            var field = (macro class {
                public var $name = $expr;
            }).fields[0];
            field.doc = '`@${meta.metadata}`\n';
            if (meta.doc != null && meta.doc != '') field.doc += '- - -\n${meta.doc}';
            if (meta.devcomment != null) field.doc += '\n${meta.devcomment}';
            if (meta.internal != null && meta.internal) field.doc += '\n- - -\nFor internal compiler use only.';
            if (meta.platforms != null) field.doc += '\n- - -\nPlatform${meta.platforms.length == 0 ? 's' :''}: ${meta.platforms.join(' | ')}';
            if (meta.targets != null) field.doc += '\n- - -\nApplies to: ${meta.targets.map( s -> s.substr(1) ).join(' | ')}';
            if (meta.params != null) for (p in meta.params) field.doc += '\n@param ${p}';
            if (meta.links != null) for (l in meta.links) field.doc += '\n@see $l';

            //trace( printer.printField( field ) );
            //break;
            fields.push( field );

        }

        var td:TypeDefinition = macro class {
            
        }
        td.doc = 'Do not edit this file it is auto-generated.\nBuilt off `meta.json` found at https://raw.githubusercontent.com/HaxeFoundation/haxe/development/src-json/meta.json';
        td.pack = ['haxe', 'macro'];
        td.name = 'Metas';
        td.kind = TDAbstract(macro:String, [macro:String], [macro:String]);
        td.meta = [
            {name:':enum', params:[], pos:td.pos}, 
            {name:':forward', params:[], pos:td.pos}, 
            {name:':forwardStatics', params:[], pos:td.pos}
        ];
        td.fields = fields.concat(td.fields);

        if (!outputPath.directory().exists()) outputPath.directory().createDirectory();
        File.saveContent(outputPath, printer.printTypeDefinition(td, true));
    }

}